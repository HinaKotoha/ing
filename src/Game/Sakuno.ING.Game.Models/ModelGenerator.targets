<Project>

  <ItemGroup>
    <UpToDateCheckInput Include="$(MSBuildThisFileFullPath);@(ClassTemplate)" />
    <None Update="@(ClassTemplate)">
      <Generator>MSBuild:UpdateClassTemplate</Generator>
      <LastGenOutput>%(RelativeDir)%(Filename).g.cs</LastGenOutput>
    </None>
  </ItemGroup>

  <UsingTask TaskName="CalculatedClassTemplate" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Inputs ParameterType="System.String[]" Required="True" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Xml.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
string xmlns = "http://schemas.heavenlywind.cc/xsd/game_model_generator";
foreach (var infile in Inputs)
{
    string outfile = Path.ChangeExtension(infile, ".g.cs");
    Log.LogMessage("{0} -> {1}", infile, outfile);
    XElement root;
    using (var input = File.OpenText(infile))
        root = XDocument.Load(input).Root;

    using var output = File.CreateText(outfile);

    output.WriteLine("//------------------------------------------------------------------------------");
    output.WriteLine("// <auto-generated>");
    output.WriteLine("//     This code was generated by a tool.");
    output.WriteLine("//");
    output.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
    output.WriteLine("//     the code is regenerated.");
    output.WriteLine("// </auto-generated>");
    output.WriteLine("//------------------------------------------------------------------------------");

    output.WriteLine("using System;");
    output.WriteLine("using System.CodeDom.Compiler;");
    output.WriteLine("using System.Collections.Generic;");
    output.WriteLine("using System.ComponentModel;");
    foreach (var ns in root.Elements(XName.Get("using", xmlns)))
        output.WriteLine($"using {ns.Value};");
    output.WriteLine();

    output.WriteLine($"namespace {root.Attribute("namespace").Value}");
    output.WriteLine("{");

    foreach (var c in root.Elements(XName.Get("class", xmlns)))
    {
        string implClass = c.Attribute("impl")?.Value;
        bool @virtual = implClass != null;
        string thisClass = c.Attribute("name").Value;
        string idClass = c.Attribute("id").Value;
        string rawClass = c.Attribute("raw").Value;
        string ownerClass = c.Attribute("owner").Value;
        bool hasName = false;

        if (@virtual)
            output.WriteLine($"    public abstract partial class {thisClass} : BindableObject");
        else
            output.WriteLine($"    public sealed partial class {thisClass} : BindableObject, IComparable<{thisClass}>, IUpdatable<{idClass}, {rawClass}>");
        output.WriteLine("    {");

        foreach (var p in c.Elements(XName.Get("property", xmlns)))
        {
            output.WriteLine();
            string propName = p.Attribute("name").Value;
            string propType = p.Attribute("type").Value;
            string fieldName = "_" + char.ToLowerInvariant(propName[0]) + propName.Substring(1);
            string accessibility = p.Attribute("set")?.Value ?? (@virtual ? "protected" : "private");
            output.WriteLine("        [EditorBrowsable(EditorBrowsableState.Never)]");
            output.WriteLine($"        private static readonly PropertyChangedEventArgs __eventArgs{fieldName} = new PropertyChangedEventArgs(nameof({propName}));");
            output.WriteLine("        [EditorBrowsable(EditorBrowsableState.Never)]");
            output.WriteLine($"        private {propType} {fieldName};");
            output.WriteLine($"        public {propType} {propName}");
            output.WriteLine("        {");
            output.WriteLine($"            get => {fieldName};");
            output.WriteLine($"            {accessibility} set => Set(ref {fieldName}, value, __eventArgs{fieldName});");
            output.WriteLine("        }");
        }

        if (@virtual)
        {
            output.WriteLine("    }");
            output.WriteLine($"    public sealed partial class {implClass} : {thisClass}, IComparable<{implClass}>, IUpdatable<{idClass}, {rawClass}>");
            output.WriteLine("    {");
        }
        else
            output.WriteLine();

        output.WriteLine($"        public int CompareTo({implClass ?? thisClass} other) => Id.CompareTo(other?.Id ?? default);");
        output.WriteLine();

        foreach (var l in c.Elements(XName.Get("localizable", xmlns)))
        {
            string propName = l.Attribute("name").Value;
            string fieldName = "_" + char.ToLowerInvariant(propName[0]) + propName.Substring(1);
            if (propName == "Name") hasName = true;
            output.WriteLine("        [EditorBrowsable(EditorBrowsableState.Never)]");
            output.WriteLine($"        private static readonly PropertyChangedEventArgs __eventArgs{fieldName} = new PropertyChangedEventArgs(nameof({propName}));");
            output.WriteLine("        [EditorBrowsable(EditorBrowsableState.Never)]");
            output.WriteLine($"        private TextTranslationDescriptor {fieldName};");
            output.WriteLine($"        public TextTranslationDescriptor {propName}");
            output.WriteLine("        {");
            output.WriteLine($"            get => {fieldName};");
            output.WriteLine($"            private set => Set(ref {fieldName}, value, __eventArgs{fieldName});");
            output.WriteLine("        }");
            output.WriteLine();
        }

        foreach (var s in c.Elements(XName.Get("snapshot", xmlns)))
        {
            string name = s.Attribute("name").Value;
            string type = s.Attribute("type").Value;
            string field = char.ToLowerInvariant(name[0]) + name.Substring(1);
            output.WriteLine($"        private readonly BindableSnapshotCollection<{type}> {field} = new BindableSnapshotCollection<{type}>();");
            output.WriteLine($"        public IReadOnlyList<{type}> {name} => {field};");
            output.WriteLine();
        }

        output.WriteLine($"        public {idClass} Id {{ get; }}");
        output.WriteLine($"        private readonly {ownerClass} _owner;");

        output.WriteLine();
        output.WriteLine($"        public {implClass ?? thisClass}({idClass} id, {ownerClass} owner)");
        output.WriteLine("        {");
        output.WriteLine("            Id = id;");
        output.WriteLine("            _owner = owner;");
        output.WriteLine("            CreateCore();");
        output.WriteLine("        }");

        output.WriteLine();
        output.WriteLine($"        public {implClass ?? thisClass}({rawClass} raw, {ownerClass} owner) : this(raw.Id, owner) => Update(raw);");

        output.WriteLine();
        output.WriteLine("        partial void CreateCore();");
        output.WriteLine();
        output.WriteLine($"        public void Update({rawClass} raw)");
        output.WriteLine("        {");
        foreach (var l in c.Elements(XName.Get("localizable", xmlns)))
        {
            string propName = l.Attribute("name").Value;
            string preferOrigin = l.Attribute("preferOrigin")?.Value ?? "true";
            output.WriteLine($"            if (raw.{propName} != {propName}?.Origin)");
            output.WriteLine($"                {propName} = new TextTranslationDescriptor(Id, \"{l.Attribute("category").Value}\", raw.{propName}, {preferOrigin});");
            output.WriteLine();
        }
        foreach (var p in c.Elements(XName.Get("property", xmlns)).Where(x => x.Attribute("autoFill")?.Value == "true"))
        {
            string prop = p.Attribute("name").Value;
            output.WriteLine($"            {prop} = raw.{prop};");
        }
        output.WriteLine();
        output.WriteLine("            UpdateCore(raw);");
        output.WriteLine("        }");

        output.WriteLine();
        output.WriteLine("        [GeneratedCode(\"Game objects generator\", \"\")]");
        output.WriteLine($"        partial void UpdateCore({rawClass} raw);");

        if (c.Attribute("noToString")?.Value != "true")
        {
            output.WriteLine();
            if (hasName)
                output.WriteLine($"        public override string ToString() => $\"{implClass ?? thisClass} {{Id}}: {{Name.Origin}}\";");
            else
                output.WriteLine($"        public override string ToString() => $\"{implClass ?? thisClass} {{Id}}\";");
        }

        output.WriteLine("    }");
        output.WriteLine();
    }

    output.WriteLine("}");
}
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="UpdateClassTemplate" Inputs="$(MSBuildThisFileFullPath);@(ClassTemplate)" Outputs="@(ClassTemplate->'%(RelativeDir)%(Filename).g.cs')" BeforeTargets="CoreCompile">
    <CalculatedClassTemplate Inputs="@(ClassTemplate)" />
  </Target>

  <PropertyGroup>
    <CoreCompileDependsOn>UpdateClassTemplate;$(CoreCompileDependsOn)</CoreCompileDependsOn>
  </PropertyGroup>

</Project>
