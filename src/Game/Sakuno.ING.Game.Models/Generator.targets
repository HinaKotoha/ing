<Project>
  <ItemGroup>
    <UpToDateCheckInput Include="$(MSBuildThisFileFullPath);@(ClassTemplate)" />
    <None Update="@(ClassTemplate)">
      <Generator>MSBuild:UpdateClassTemplate</Generator>
      <LastGenOutput>%(RelativeDir)%(Filename).g.cs</LastGenOutput>
    </None>
  </ItemGroup>

  <UsingTask TaskName="CalculatedClassTemplate" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Inputs ParameterType="System.String[]" Required="True" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Xml.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
foreach (var infile in Inputs)
{
    string outfile = Path.ChangeExtension(infile, ".g.cs");
    Log.LogMessage("{0} -> {1}", infile, outfile);
    XElement root;
    using (var input = File.OpenText(infile))
        root = XDocument.Load(input).Root;

    using (var output = File.CreateText(outfile))
    {
        output.WriteLine("//------------------------------------------------------------------------------");
        output.WriteLine("// <auto-generated>");
        output.WriteLine("//     This code was generated by a tool.");
        output.WriteLine("//");
        output.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        output.WriteLine("//     the code is regenerated.");
        output.WriteLine("// </auto-generated>");
        output.WriteLine("//------------------------------------------------------------------------------");

        output.WriteLine("using System;");
        output.WriteLine("using System.Collections.Generic;");
        output.WriteLine("using System.ComponentModel;");
        foreach (var ns in root.Elements("using"))
            output.WriteLine($"using {ns.Value};");
        output.WriteLine();

        output.WriteLine($"namespace {root.Attribute("namespace").Value}");
        output.WriteLine("{");

        foreach (var c in root.Elements("class"))
        {
            string implClass = c.Attribute("impl")?.Value;
            bool @virtual = implClass != null;
            string thisClass = c.Attribute("name").Value;
            string idClass = c.Attribute("id").Value;
            string rawClass = c.Attribute("raw").Value;
            string ownerClass = c.Attribute("owner").Value;
            bool hasName = false;

            if (@virtual)
                output.WriteLine($"    public abstract partial class {thisClass} : BindableObject");
            else
                output.WriteLine($"    public sealed partial class {thisClass} : BindableObject, IUpdatable<{idClass}, {rawClass}>");
            output.WriteLine("    {");

            foreach (var p in c.Elements("property"))
            {
                output.WriteLine();
                string propName = p.Attribute("name").Value;
                string propType = p.Attribute("type").Value;
                string fieldName = "_" + char.ToLowerInvariant(propName[0]) + propName.Substring(1);
                string accessibility = p.Attribute("set")?.Value ?? (@virtual ? "protected" : "private");
                output.WriteLine("        [EditorBrowsable(EditorBrowsableState.Never)]");
                output.WriteLine($"        private static readonly PropertyChangedEventArgs __eventArgs{fieldName} = new PropertyChangedEventArgs(nameof({propName}));");
                output.WriteLine("        [EditorBrowsable(EditorBrowsableState.Never)]");
                output.WriteLine($"        private {propType} {fieldName};");
                output.WriteLine($"        public {propType} {propName}");
                output.WriteLine("        {");
                output.WriteLine($"            get => {fieldName};");
                output.WriteLine($"            {accessibility} set => Set(ref {fieldName}, value, __eventArgs{fieldName});");
                output.WriteLine("        }");
            }

            if (@virtual)
            {
                output.WriteLine("    }");
                output.WriteLine($"    internal sealed partial class {implClass} : {thisClass}, IUpdatable<{idClass}, {rawClass}>");
                output.WriteLine("    {");
            }
            else
                output.WriteLine();

            foreach (var l in c.Elements("localizable"))
            {
                output.WriteLine($"        public TextTranslationGroup {l.Attribute("name").Value} {{ get; }} = new TextTranslationGroup();");
                output.WriteLine();
            }
            foreach (var s in c.Elements("snapshot"))
            {
                string name = s.Attribute("name").Value;
                string type = s.Attribute("type").Value;
                string field = char.ToLowerInvariant(name[0]) + name.Substring(1);
                output.WriteLine($"        private readonly BindableSnapshotCollection<{type}> {field} = new BindableSnapshotCollection<{type}>();");
                output.WriteLine($"        public IReadOnlyList<{type}> {name} => {field};");
                output.WriteLine();
            }

            output.WriteLine($"        public {idClass} Id {{ get; }}");
            output.WriteLine($"        private readonly {ownerClass} owner;");
            output.WriteLine("        public DateTimeOffset UpdationTime { get; private set; }");

            output.WriteLine();
            output.WriteLine($"        public {implClass ?? thisClass}({idClass} id, {ownerClass} owner)");
            output.WriteLine("        {");
            output.WriteLine("            Id = id;");
            output.WriteLine("            this.owner = owner;");
            foreach (var l in c.Elements("localizable"))
            {
                string propName = l.Attribute("name").Value;
                if (propName == "Name") hasName = true;
                output.WriteLine($"            {propName}.Translation = owner.Localization?.GetLocalized(\"{l.Attribute("category").Value}\", id.ToString());");
            }
            output.WriteLine("            CreateCore();");
            output.WriteLine("        }");

            output.WriteLine();
            output.WriteLine($"        public {implClass ?? thisClass}({rawClass} raw, {ownerClass} owner, DateTimeOffset timeStamp) : this(raw.Id, owner) => UpdateProps(raw, timeStamp);");

            output.WriteLine();
            output.WriteLine($"        public event Action<{implClass ?? thisClass}, {rawClass}, DateTimeOffset> Updating;");
            output.WriteLine($"        public void Update({rawClass} raw, DateTimeOffset timeStamp)");
            output.WriteLine("        {");
            output.WriteLine("            Updating?.Invoke(this, raw, timeStamp);");
            output.WriteLine("            using (EnterBatchNotifyScope())");
            output.WriteLine("                UpdateProps(raw, timeStamp);");
            output.WriteLine("        }");

            output.WriteLine();
            output.WriteLine($"        private void UpdateProps({rawClass} raw, DateTimeOffset timeStamp)");
            output.WriteLine("        {");
            output.WriteLine("            UpdationTime = timeStamp;");
            foreach (var l in c.Elements("localizable"))
            {
                string propName = l.Attribute("name").Value;
                output.WriteLine();
                output.WriteLine($"            if (raw.{propName} != {propName}.Origin)");
                output.WriteLine("            {");
                output.WriteLine($"                {propName}.Origin = raw.{propName};");
                output.WriteLine($"                NotifyPropertyChanged(nameof({propName}));");
                output.WriteLine("            }");
            }
            output.WriteLine();
            foreach (var p in c.Elements("property").Where(x => x.Attribute("autoFill")?.Value == "true"))
            {
                string prop = p.Attribute("name").Value;
                output.WriteLine($"            {prop} = raw.{prop};");
            }
            output.WriteLine();
            output.WriteLine("            UpdateCore(raw, timeStamp);");
            output.WriteLine("        }");

            output.WriteLine();
            output.WriteLine($"        partial void UpdateCore({rawClass} raw, DateTimeOffset timeStamp);");
            output.WriteLine();
            output.WriteLine("        partial void CreateCore();");

            if (c.Attribute("noToString")?.Value != "true")
            {
                output.WriteLine();
                if (hasName)
                    output.WriteLine($"        public override string ToString() => $\"{implClass ?? thisClass} {{Id}}: {{Name.Origin}}\";");
                else
                    output.WriteLine($"        public override string ToString() => $\"{implClass ?? thisClass} {{Id}}\";");
            }

            output.WriteLine("    }");
            output.WriteLine();
        }

        output.WriteLine("}");
        output.Flush();
    }
}
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="UpdateClassTemplate" Inputs="$(MSBuildThisFileFullPath);@(ClassTemplate)" Outputs="@(ClassTemplate->'%(RelativeDir)%(Filename).g1.cs')" BeforeTargets="CoreCompile">
    <CalculatedClassTemplate Inputs="@(ClassTemplate)" />
  </Target>

  <PropertyGroup>
    <CoreCompileDependsOn>UpdateClassTemplate;$(CoreCompileDependsOn)</CoreCompileDependsOn>
  </PropertyGroup>
</Project>
