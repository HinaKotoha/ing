<Project>
  <ItemGroup>
    <UpToDateCheckInput Include="$(MSBuildThisFileFullPath);@(Scaffold)" />
    <None Update="@(Scaffold)">
      <Generator>MSBuild:UpdateScaffold</Generator>
      <LastGenOutput>%(RelativeDir)%(Filename).g.cs</LastGenOutput>
    </None>
  </ItemGroup>

  <UsingTask TaskName="CalculatedScaffold" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Inputs ParameterType="System.String[]" Required="True" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
foreach (var infile in Inputs)
{
    string outfile = Path.ChangeExtension(infile, ".g.cs");
    Log.LogMessage("{0} -> {1}", infile, outfile);
    using (var input = File.OpenText(infile))
    using (var output = File.CreateText(outfile))
    {
        output.WriteLine(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------");
        var ns = input.ReadLine();
        while (true)
        {
            var line = input.ReadLine();
            if (string.IsNullOrEmpty(line))
                break;
            output.WriteLine($"using {line};");
        }
        output.WriteLine();
        output.WriteLine($"namespace {ns}");
        output.WriteLine("{");
        while (!input.EndOfStream)
        {
            var classes = input.ReadLine().Split(':');
            string thisClass = classes[0];
            string idClass = classes[1];
            string rawClass = classes[2];
            string ownerClass = classes[3];
            var props = new List<string>();
            var bindables = new List<string>();
            var localizables = new List<string>();
            bool hasName = false;
            while (true)
            {
                var line = input.ReadLine();
                int p = line.IndexOf(':');
                if (p < 0) break;
                switch (line.Substring(0, p))
                {
                    case "p":
                        props.Add(line.Substring(p + 1));
                        break;
                    case "b":
                        bindables.Add(line.Substring(p + 1));
                        break;
                    case "l":
                        localizables.Add(line.Substring(p + 1));
                        break;
                }
            }
            output.WriteLine($"    public partial class {thisClass} : Calculated<{idClass}, {rawClass}>");
            output.WriteLine("    {");
            output.WriteLine($"        public {thisClass}({idClass} id, {ownerClass} owner) : base(id)");
            output.WriteLine("        {");
            output.WriteLine("            this.owner = owner;");
            var unlocalized = new List<string>();
            foreach (var l in localizables)
            {
                var prop = l.Split(' ');
                string propName = prop[0];
                string category = prop[1];
                if (propName == "Name")
                    hasName = true;
                output.WriteLine($"            {propName}.Translation = owner.Localization?.GetLocalized(\"{category}\", id.ToString());");
            }
            output.WriteLine("            CreateDummy();");
            output.WriteLine("        }");
            output.WriteLine();
            output.WriteLine($"        public {thisClass}({rawClass} raw, {ownerClass} owner, DateTimeOffset timeStamp) : this(raw.Id, owner) => UpdateProps(raw, timeStamp);");
            output.WriteLine();
            output.WriteLine($"        private readonly {ownerClass} owner;");
            var dummyList = new List<string>();
            foreach (var l in localizables)
            {
                var prop = l.Split(' ');
                output.WriteLine();
                string propName = prop[0];
                output.WriteLine($"        public TextTranslationGroup {propName} {{ get; }} = new TextTranslationGroup();");
            }
            foreach (var line in props)
            {
                var prop = line.Split(' ');
                string propName = prop[1];
                string propType = prop[0];
                string fieldName = "_" + char.ToLowerInvariant(propName[0]) + propName.Substring(1);
                if (prop.Length >= 3 && prop[2] == "-")
                    dummyList.Add(propName);
                output.WriteLine();
                output.WriteLine("        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
                output.WriteLine($"        private static readonly System.ComponentModel.PropertyChangedEventArgs __eventArgs_{fieldName} = new System.ComponentModel.PropertyChangedEventArgs(nameof({propName}));");
                output.WriteLine($"        private {propType} {fieldName};");
                output.WriteLine($"        public {propType} {propName}");
                output.WriteLine("        {");
                output.WriteLine($"            get => {fieldName};");
                output.WriteLine($"            internal set => Set(ref {fieldName}, value, __eventArgs_{fieldName});");
                output.WriteLine("        }");
            }
            output.WriteLine();
            output.WriteLine($"        public event Action<{thisClass}, {rawClass}, DateTimeOffset> Updating;");
            output.WriteLine($"        public override void Update({rawClass} raw, DateTimeOffset timeStamp)");
            output.WriteLine("        {");
            output.WriteLine("            Updating?.Invoke(this, raw, timeStamp);");
            output.WriteLine("            using (var scope = EnterBatchNotifyScope())");
            output.WriteLine("                UpdateProps(raw, timeStamp);");
            output.WriteLine("        }");
            output.WriteLine();
            output.WriteLine($"        private void UpdateProps({rawClass} raw, DateTimeOffset timeStamp)");
            output.WriteLine("        {");
            output.WriteLine("            UpdationTime = timeStamp;");
            foreach (string l in localizables)
            {
                output.WriteLine();
                var prop = l.Split(' ');
                string propName = prop[0];
                output.WriteLine($"            if (raw.{propName} != {propName}.Origin)");
                output.WriteLine("            {");
                output.WriteLine($"                {propName}.Origin = raw.{propName};");
                output.WriteLine($"                NotifyPropertyChanged(nameof({propName}));");
                output.WriteLine("            }");
            }
            output.WriteLine();
            foreach (string prop in dummyList)
                output.WriteLine($"            {prop} = raw.{prop};");
            output.WriteLine();
            output.WriteLine("            UpdateCore(raw, timeStamp);");
            output.WriteLine("        }");
            output.WriteLine();
            output.WriteLine($"        partial void UpdateCore({rawClass} raw, DateTimeOffset timeStamp);");
            output.WriteLine("        partial void CreateDummy();");
            foreach (var b in bindables)
            {
                var prop = b.Split(' ');
                string name = prop[1];
                string type = prop[0];
                string field = char.ToLowerInvariant(name[0]) + name.Substring(1);
                output.WriteLine();
                output.WriteLine($"        private readonly BindableSnapshotCollection<{type}> {field} = new BindableSnapshotCollection<{type}>();");
                output.WriteLine($"        public IReadOnlyList<{type}> {name} => {field};");
            }
            if (hasName)
            {
                output.WriteLine();
                output.WriteLine($"        public override string ToString() => $\"{thisClass} {{Id}}: {{Name.Origin}}\";");
            }
            output.WriteLine("    }");
        }
        output.WriteLine("}");
        output.Flush();
    }
}
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="UpdateScaffold" Inputs="$(MSBuildThisFileFullPath);@(Scaffold)" Outputs="@(Scaffold->'%(RelativeDir)%(Filename).g.cs')" BeforeTargets="CoreCompile">
    <CalculatedScaffold Inputs="@(Scaffold)" />
  </Target>

  <PropertyGroup>
    <CoreCompileDependsOn>UpdateScaffold;$(CoreCompileDependsOn)</CoreCompileDependsOn>
  </PropertyGroup>
</Project>
